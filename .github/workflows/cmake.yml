# https://github.com/actions/starter-workflows/blob/main/ci/cmake-multi-platform.yml

name: CMake CI/CD
permissions:
  contents: read

on:
  push:
    branches: [ main, dev ]
    paths:
      - "**.c"
      - "**.h"
      - CMakeLists.txt
      - .github/workflows/cmake.yml

  pull_request:
    branches: [ main, dev ]
    paths:
      - "**.c"
      - "**.h"
      - CMakeLists.txt
      - .github/workflows/cmake.yml

jobs:
  CI_CD:
    name: Cmake CI/CD
    runs-on: ${{matrix.os}}

    env:
      IS_MAIN_BRANCH: ${{ (github.event_name == 'push' && github.head_ref == 'main') || github.ref_name == 'main'  }}

    strategy:
      fail-fast: false
      max-parallel: 3

      matrix:
        os: [windows-latest]
        build_type: [Debug]
        c_compiler: [gcc, clang, cl]
        include:
          - os: windows-latest
            c_compiler: cl
          # - os: ubuntu-latest
          #   c_compiler: gcc
          # - os: ubuntu-latest
          #   c_compiler: clang
          # - os: macos-latest
          #   c_compiler: gcc
          # - os: macos-latest
          #   c_compiler: clang
        exclude:
          - os: windows-latest
            c_compiler: gcc
          - os: windows-latest
            c_compiler: clang
          - os: ubuntu-latest
            c_compiler: cl
          - os: macos-latest
            c_compiler: cl

    steps:
    - name: Checkout repo
      uses: actions/checkout@v4

    - name: Set reusable strings
      # Turn repeated input strings (such as the build output directory) into step outputs.
      # These step outputs can be used throughout the workflow file.
      id: strings
      shell: bash
      run: |
        echo "build-output-dir=${{github.workspace}}/build" >> "$GITHUB_OUTPUT"
        echo "artifact-name=CLipt-${{matrix.os}}-${{matrix.c_compiler}}-${{matrix.build_type}}" >> "$GITHUB_OUTPUT"
        echo "test-executable=${{github.workspace}}/build/bin/${{matrix.build_type}}/test_suite" >> "$GITHUB_OUTPUT"
        echo "repl-executable=${{github.workspace}}/build/bin/${{matrix.build_type}}/clipti" >> "$GITHUB_OUTPUT"


    # Install clang tidy
    - name: Install clang-tidy
      if: env.IS_MAIN_BRANCH
      uses: ConorMacBride/install-package@v1
      with:
        apt: clang-tidy
        brew: llvm

    - name: Setup path to clang-tidy (MacOS)
      if: runner.os == 'macOS'
      run: |
        echo "PATH=$(brew --prefix llvm)/bin:${PATH}" >> $GITHUB_ENV

    - name: Setup path to clang-tidy (Windows)
      if: runner.os == 'Windows'
      run: |
        echo "PATH=C:\Program Files\LLVM\bin;${PATH}" >> $GITHUB_ENV

    - name: Configure CMake
      # Configure CMake in a 'build' subdirectory. `CMAKE_BUILD_TYPE` is only required
      # if you are using a single-configuration generator such as make.
      # See https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html?highlight=cmake_build_type
      run: >
        cmake -S ${{github.workspace}} -B ${{steps.strings.outputs.build-output-dir}}
        -DCMAKE_BUILD_TYPE=${{matrix.build_type}}
        -DCMAKE_C_COMPILER=${{matrix.c_compiler}}
        -DCMAKE_C_FLAGS="-fsanitize=address -fno-omit-frame-pointer"
        -DENABLE_CLANG_TIDY=ON -DCLANG_TIDY_WARNINGS_AS_ERRORS=${{((env.IS_MAIN_BRANCH == 'true') && 'ON') || 'OFF'}}


    - name: Build
      # Build your program with the given configuration. Note that --config is needed because
      # the default Windows generator is a multi-config generator (Visual Studio generator).
      run: cmake --build ${{steps.strings.outputs.build-output-dir}} --config ${{matrix.build_type}}

    - name: View ctest config
      working-directory: ${{steps.strings.outputs.build-output-dir}}
      run: |
        "cat ${{steps.strings.outputs.build-output-dir}}/CTestTestfile.cmake"


    - name: Test
      working-directory: ${{steps.strings.outputs.build-output-dir}}
      # Execute tests defined by the CMake configuration. Note that --build-config is needed because
      # the default Windows generator is a multi-config generator (Visual Studio generator).
      # See https://cmake.org/cmake/help/latest/manual/ctest.1.html for more detail
      run: |
        Get-ChildItem -Recursive -Path "${{steps.strings.outputs.build-output-dir}}/bin"
        Get-ChildItem -Recursive -Path "${{steps.strings.outputs.build-output-dir}}/lib"
        $Env:PATH += ";${{steps.strings.outputs.build-output-dir}}/lib/${{matrix.build_type}}"
        $Env:PATH += ";${{steps.strings.outputs.build-output-dir}}/bin/${{matrix.build_type}}"
        $Env:PATH += ";${{steps.strings.outputs.build-output-dir}}/lib/"
        $Env:PATH += ";${{steps.strings.outputs.build-output-dir}}/bin"
        ctest --output-on-failure --build-config ${{matrix.build_type}}

    - name: Pack
      working-directory: ${{steps.strings.outputs.build-output-dir}}
      run: cpack

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{steps.strings.outputs.artifact-name}}
        path: ${{steps.strings.outputs.build-output-dir}}/Packaging/*.*
        retention-days: 7
        if-no-files-found: error


    # Run memory leak tests
    - name: Install Valgrind or DrMemory
      uses: ConorMacBride/install-package@v1
      with:
        apt: valgrind
        choco: drmemory

    - name: Run memory leak tests (Linux)
      working-directory: ${{steps.strings.outputs.build-output-dir}}
      if: runner.os == 'Linux'
      run: |
        valgrind --leak-check=full --show-leak-kinds=all -s ctest

    - name: Run memory leak tests (MacOS)
      working-directory: ${{steps.strings.outputs.build-output-dir}}
      if: runner.os == 'macOS'
      run: |
        MallocStackLogging=1 leaks -atExit -- ctest

    - name: Run memory leak tests (Windows)
      working-directory: ${{steps.strings.outputs.build-output-dir}}
      if: runner.os == 'Windows'
      run: |
        drmemory -leak_check -ignore_kernel -batch -results_to_stdout -- ctest
